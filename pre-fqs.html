<!DOCTYPE html>
<html>
<!--
  This file contains an HTML app for writing and rendering musical scores
  using the FQS notation system.  It defines the structure and layout of the
  score, including the placement of various elements such as title, cue, lyric,
  chord, dynamics, time signature, and pitches.

  The app uses SVG (Scalable Vector Graphics) to render the musical
  notation. The SVG elements are dynamically generated and positioned based on
  the provided musical data and configuration parameters.
  
  To understand how the app works and how the musical data is processed and
  rendered, you can refer to the following sections in the JavaScript code:

  0. The window.onload function: This function is called when the HTML file is
  loaded. It finds all the score elements (div.score) in the HTML file and
  renders them using the `renderEditedScoreSource()` function.
  
  1. The `renderScore()` function: This is the main entry point for rendering a
  score. It sets up the SVG container, applies the necessary transformations,
  and calls the respective rendering functions for each musical element class.
  
  2. The rendering functions for each musical element class (e.g.,
  Title.render(), Cue.render(), Lyric.render(), etc.): These functions handle
  the rendering of specific musical elements based on the provided data. They
  create the necessary SVG elements, set their attributes, and position them
  correctly within the score.
  
  3. The `bookParameters` object: This object contains various configuration
  parameters that control the rendering of the score, such as font heights,
  spacing, and positioning. These parameters are used throughout the rendering
  process to ensure consistent and customizable formatting. Also, see the
  <style> element in the HTML file for the CSS rules that control the formatting
  of the score.
  
  4. The `handleNewScoreButtonClick()` function: This function is called when
  the user clicks the Insert button.  It opens the dialog box for selecting a
  score template. This function is called when the user clicks the Insert
  button. It opens a dialog box where the user can choose an initial score
  template (e.g., Minimal, Full, Cheat sheet) and inserts a new score based on
  the selected template using the insertNewScore() function.
  
  5. The export() and importFromFile() functions: These functions are invoked
  by buttons in the control dropdown at the top of the page. The export
  function saves the current score data to a file and the importFromFile
  function loads a score file, splits the text into individual scores, and
  appends them to the page as separate scores.

  6. Common syntax errors in the pitch line are detected and displayed in the
  rendered output in red text below the line where the error occurred. See the
  LineProblems class and renderScore() for details. Processing continues if
  possible so that the user is not interrupted by a syntax error while
  transcribing a score.
  
  Feel free to explore the code and experiment with different musical data and
  configuration parameters to understand how the app works and how you can
  customize it to suit your needs.
-->

<head>
  <meta charset="utf-8">
  </meta>
  <link rel="stylesheet" href="fqs.css">
</head>

<body>
  <!--YouTube player div-->
  <div id="player"></div>
  <!-- Page controls -->
  <div style="margin-left: 5%; margin-right: 5%;">
    <em>Controls</em><br>
    <button id="exportButton" onclick="exportScores()">Export</button> <em>Save the scores from this page in
      <code>.fqs</code> text
      format.</em><br>
    <button onclick="importFromFile()">Import File</button> <em>Import scores from a local <code>.fqs</code>
      file.</em><br>
    <button onclick="importFromURL()">Import URL</button> <em>Import a <code>.fqs</code> file from a URL.</em><br>
    <button id="edit-btn">Show edit controls</button> <em>Display the editable source beside the score. </em>

    <script>
      // Add right after the first <script> tag
      let tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      tag.onload = () => {
        console.log('YouTube IFrame API script loaded');
      };
      let firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      let editModeState = true;
      const editButton = document.getElementById('edit-btn');
      function toggleEdit() {
        editModeState = !editModeState;
        forceEditMode(editModeState);
      }
      function forceEditMode(boolValue) {
        newScoreBtnsVisible(editModeState);
        const scoreDivs = document.querySelectorAll('div.score');
        scoreDivs.forEach(div => {
          const editor = div.querySelector('div.source-div');
          const rendered = div.querySelector('div.inner-wrapper');
          const deleteBtn = div.querySelector('button.delete-btn');
          if (editModeState) {
            editor.style.display = 'block';
            editor.style.width = '50%';
            rendered.style.width = '50%';
            deleteBtn.style.display = 'inline-block';
            editButton.textContent = 'Hide edit controls';
          } else {
            editor.style.display = 'none';
            rendered.style.width = '100%';
            deleteBtn.style.display = 'none';
            editButton.textContent = 'Show edit controls';
          }
        });
      }
      editButton.addEventListener('click', toggleEdit);
      // deleteScore(id) deletes the score div with the given id and all its
      // content from the DOM along with the Insert button that follows it.
      function deleteScore(id) {
        const score = document.getElementById(id);
        if (score === null) {
          return
        }
        score.remove();
        btnId = "insert-new-" + id;
        const insertButton = document.getElementById(btnId);
        if (insertButton !== null) {
          insertButton.remove();
        }
        scoreToc(); // update the table of contents
      }
      // scoreToc is a function that generates a table of contents for the scores in the
      // current page. It creates a ul element that contains li elements for each score.
      // Each li element contains a link to the score's div element. The link text is the
      // title of the score. The title is extracted from the first line of the score's
      // source. The ul is inserted into the div with id'score-toc'.
      function scoreToc() {
        let toc = document.getElementById('score-toc');
        // if score-toc div doesn't exist, create it as the first
        // child of body
        if (toc === null) {
          const body = document.querySelector('body');
          toc = document.createElement('div');
          toc.id = 'score-toc';
          body.insertBefore(toc, body.firstChild);
        } else {
          toc.innerHTML = ''; // Clear it
        }
        const scores = document.querySelectorAll('div.score');
        if (scores.length === 0) {
          return;
        }
        const ul = document.createElement('ul');
        for (const score of scores) {
          const text = score.querySelector('pre.source').textContent.split('\n');
          // find the title line of the score's source
          const titleline = text.find(line => line.trim().startsWith('title:'));
          const title = titleline.split(':')[1].trim();
          const li = document.createElement('li');
          const a = document.createElement('a');
          a.setAttribute('href', `#${score.id}`);
          a.textContent = title;
          li.appendChild(a);
          ul.appendChild(li);
        }
        // insert the ul of score links into the toc div
        toc.appendChild(ul);
        insertPageBreak(toc);
        return;
      }

      function newScoreContent(intChoice) {
        const choices = {
          minimal: `title: Untitled 

music: K0 c d e f |
counter: 1

`,

          cheatsheet: fqsReference
        }
        switch (intChoice) {
          case 1:
            return choices.minimal;
          case 3:
            return choices.cheatsheet
          default:
            return choices.minimal
        }
      }
      // The export method creates a text file consisting of the source texts of each
      // score in the document, catenated and separated by a blank line between scores.
      // The source texts are located in the pre elements with class'source'.
      function exportScores() {
        // Get the source texts of each score
        const scoreDivs = document.querySelectorAll('div.score');
        const scoreTexts = [];
        scoreDivs.forEach(div => {
          scoreTexts.push(div.querySelector('pre.source').textContent);
        });
        // Create a text file
        const blob = new Blob([scoreTexts.join('\nEndOfScore\n')], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.setAttribute('href', url);
        // get this html document's name and append '-source.fqs' to it.
        const fqsName = window.location.pathname.split('/').pop().replace('.html', '-source.fqs');
        a.setAttribute('download', fqsName);
        let saveInitiated = true;
        const initialTimestamp = Date.now();
        a.click();
        setTimeout(() => {
          if (saveInitiated && Date.now() - initialTimestamp > 1000) {
            // Assume save was successful if more than 1 second has passed.
            // This approach isn't foolproof, but it may be the best we can
            // do since the result of the File Save dialog is not available.
            isDirty = false;
          }
        }, 1500);
        // Revoke the object URL to avoid memory leaks.
        URL.revokeObjectURL(url);
        return false;
      }
      // appendScores adds a set of scores to the document.  It is called from
      // either the importFromFile or importFromURL function.
      function appendScores(text) {
        const scoreTexts = text.split('\nEndOfScore\n');
        scoreTexts.forEach(scoreText => {
          scoreObj = new Score(scoreText);
          let div = scoreObj.outer;
          const newScoreButtons = document.querySelectorAll(`button.new-score-btn`);
          let newScoreButton = newScoreButtons[newScoreButtons.length - 1]; // get the last new score button
          newScoreButton.parentNode.insertBefore(div, newScoreButton.nextSibling);
          // Add a new score button after the div
          newScoreButton = document.createElement('button');
          newScoreButton.setAttribute('class', 'new-score-btn');
          newScoreButton.setAttribute('id', `insert-new-${div.id}`);
          newScoreButton.textContent = 'Insert New Score';
          newScoreButton.addEventListener('click', handleNewScoreButtonClick);
          div.parentNode.insertBefore(newScoreButton, div.nextSibling);

          // div.appendChild(link);
          insertPageBreak(div)
          scoreObj.render()
        });
        // Honor the current edit mode state.
        forceEditMode(editModeState);
      }
      // importFromFile prompts the user to select an fqs file and imports the
      // scores in the file.
      function importFromFile() {
        const file = document.createElement('input');
        file.setAttribute('type', 'file');
        file.setAttribute('accept', '.fqs');
        file.addEventListener('change', event => {
          const file = event.target.files[0];
          const reader = new FileReader();
          reader.addEventListener('load', event => {
            const text = event.target.result;
            appendScores(text);
          });
          reader.readAsText(file);
        });
        file.click();
        return false;
      }
      // importFromURL prompts the user to enter the URL of an fqs file and
      // imports the scores
      function importFromURL() {
        const url = prompt('Enter the URL of the .fqs file:',
          "https://www.example.com/myfile.fqs");
        if (url) {
          fetch(url)
            .then(response => response.text())
            .then(text => {
              try {
                appendScores(text);
              } catch {
                console.error('Error fetching .fqs file:', error);
                alert('Error(s) encountered. Scores may be incorrectly rendered or may not be rendered at all.');
              }
            })
            .catch(error => {
              console.error('Error fetching .fqs file:', error);
              alert('Failed to fetch the .fqs file. Please check the URL and try again.');
            });
        }
        return false;
      }
    </script>

  </div>
  <h3>
    Scores
  </h3>
  <div id="score-toc" class="score-toc">
  </div>
  <button id="first-new-score-btn" , class="new-score-btn" onclick="handleNewScoreButtonClick(event)">
    Insert New Score
  </button>
  <dialog id=new-score-dialog>
    <form method="dialog">
      <p>Choose an initial score template:</p>
      <label><input type="radio" name="choice" value="1" checked> Minimal</label><br>
      <label><input type="radio" name="choice" value="3"> FQS Reference</label><br>
      <button id="cancelBtn" type="reset">Cancel</button>
      <button id="confirmBtn" type="submit">Confirm</button>
    </form>
  </dialog>
  <!-- The CSS styles for the score editor and display -->
  <style id="fqs-style">
    html,
    body {
      width: 100%;
    }

    summary {
      margin-left: 5%;
    }

    button {
      margin: 2px;
    }

    button.new-score-btn {
      margin-left: 5%;
    }

    button.delete-btn {
      margin-left: 5%;
    }

    .link-to-toc {
      /* toc links should be at the right edge of the document */
      position: absolute;
      right: 5%;

    }

    h2,
    h3,
    p,
    ul,
    ol {
      margin-left: 5%;
      margin-right: 5%;
    }
  </style>
  <script type="module">
    import { Score, initYouTubeAPI, onYouTubeIframeAPIReady } from './fqs.js';

    // Make YouTube callback globally available
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;

    // Initialize YouTube API
    initYouTubeAPI();

    const scoreMap = new Map();
    let isDirty = false; // global flag that is set when we edit a score and cleared when export the scores
    const bookParameters = {
      // bookParameters control the behavior of the score editor and display.
      leftX: 16, // Pixel position of the left edge of the score.
      sideBySide: true, // if true, render scores side-by-side with edit area
      barlineRgx: /:?\|:?/, // regular expression to match barlines
      lyricRgx: /[\p{L}']/u, // regular expression to match lyric alpha characters and apostrophes
      "lyricFontWidth": 7, // includes space between letters
      // Various font size parameters are are added to this object at runtime by 
      // by the updateFontSizes() function in this file. These are needed by the functions
      // that render the scores. If you need to change the font size, you should do so 
      // in the style tag in this file with id "fqs-style".
    }
    // insertNewScore() inserts a new score into the DOM. It is called
    // when the user chooses one of the predefined score templates from
    // the new score dialog.
    function insertNewScore(button, intChoice) {
      const scoreText = newScoreContent(parseInt(intChoice));
      scoreObj = new Score(scoreText);
      let div = scoreObj.outer;
      button.parentNode.insertBefore(div, button.nextSibling);

      const newScoreButton = document.createElement('button');
      newScoreButton.setAttribute('class', 'new-score-btn');
      newScoreButton.setAttribute('id', `insert-new-${div.id}`);
      newScoreButton.textContent = 'Insert New Score';
      newScoreButton.addEventListener('click', handleNewScoreButtonClick);
      div.parentNode.insertBefore(newScoreButton, div.nextSibling);

      // div.appendChild(link);
      insertPageBreak(div)
      scoreObj.render()
      forceEditMode(editModeState);
    }
    // handleNewScoreButtonClick inserts a new score into current page immediately before the
    // button that invoked it.  The new consists of a div with class'score' that contains
    // a <details> element that contains a <pre> element of class 'source' and a Save button that
    // invokes saveAsHtmlFile().
    function handleNewScoreButtonClick(event) {
      //console.log('handleNewScoreButtonClick');
      const button = event.target;
      dialog = document.getElementById('new-score-dialog');
      // replace the dialog with a clone
      // to prevent accumulation of event listeners.
      dialog.replaceWith(dialog.cloneNode(true));
      dialog = document.getElementById('new-score-dialog');

      const cancelButton = dialog.querySelector('button[type="reset"]');
      const confirmButton = dialog.querySelector('button[type="submit"]');

      const cancelHandler = () => {
        dialog.returnValue = '';
        dialog.close();
        return false;
      };
      const confirmHandler = () => {
        dialog.returnValue = dialog.querySelector('input[name="choice"]:checked').value;
        //console.log(`New score dialog submitted with ${dialog.returnValue}`);
        return false;
      };

      cancelButton.addEventListener('click', cancelHandler);
      confirmButton.addEventListener('click', confirmHandler);

      dialog.addEventListener('close', () => {
        if (dialog.returnValue !== '') {
          //console.log(`New score dialog closed with ${dialog.returnValue}`);
          insertNewScore(button, dialog.returnValue);
        }
        return false;
      });

      dialog.showModal();
      return false;
    }

    // The export method creates a text file consisting of the source texts of each
    // score in the document, catenated and separated by a blank line between scores.
    // The source texts are located in the pre elements with class'source'.
    function exportScores() {
      // Get the source texts of each score
      const scoreDivs = document.querySelectorAll('div.score');
      const scoreTexts = [];
      scoreDivs.forEach(div => {
        scoreTexts.push(div.querySelector('pre.source').textContent);
      });
      // Create a text file
      const blob = new Blob([scoreTexts.join('\nEndOfScore\n')], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.setAttribute('href', url);
      // get this html document's name and append '-source.fqs' to it.
      const fqsName = window.location.pathname.split('/').pop().replace('.html', '-source.fqs');
      a.setAttribute('download', fqsName);
      let saveInitiated = true;
      const initialTimestamp = Date.now();
      a.click();
      setTimeout(() => {
        if (saveInitiated && Date.now() - initialTimestamp > 1000) {
          // Assume save was successful if more than 1 second has passed.
          // This approach isn't foolproof, but it may be the best we can
          // do since the result of the File Save dialog is not available.
          isDirty = false;
        }
      }, 1500);
      // Revoke the object URL to avoid memory leaks.
      URL.revokeObjectURL(url);
      return false;
    }
    // appendScores adds a set of scores to the document.  It is called from
    // either the importFromFile or importFromURL function.
    function appendScores(text) {
      const scoreTexts = text.split('\nEndOfScore\n');
      scoreTexts.forEach(scoreText => {
        scoreObj = new Score(scoreText);
        let div = scoreObj.outer;
        const newScoreButtons = document.querySelectorAll(`button.new-score-btn`);
        let newScoreButton = newScoreButtons[newScoreButtons.length - 1]; // get the last new score button
        newScoreButton.parentNode.insertBefore(div, newScoreButton.nextSibling);
        // Add a new score button after the div
        newScoreButton = document.createElement('button');
        newScoreButton.setAttribute('class', 'new-score-btn');
        newScoreButton.setAttribute('id', `insert-new-${div.id}`);
        newScoreButton.textContent = 'Insert New Score';
        newScoreButton.addEventListener('click', handleNewScoreButtonClick);
        div.parentNode.insertBefore(newScoreButton, div.nextSibling);

        // div.appendChild(link);
        insertPageBreak(div)
        scoreObj.render()
      });
      // Honor the current edit mode state.
      forceEditMode(editModeState);
    }
    // importFromFile prompts the user to select an fqs file and imports the
    // scores in the file.
    function importFromFile() {
      const file = document.createElement('input');
      file.setAttribute('type', 'file');
      file.setAttribute('accept', '.fqs');
      file.addEventListener('change', event => {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.addEventListener('load', event => {
          const text = event.target.result;
          appendScores(text);
        });
        reader.readAsText(file);
      });
      file.click();
      return false;
    }
    // importFromURL prompts the user to enter the URL of an fqs file and
    // imports the scores
    function importFromURL() {
      const url = prompt('Enter the URL of the .fqs file:',
        "https://www.example.com/myfile.fqs");
      if (url) {
        fetch(url)
          .then(response => response.text())
          .then(text => {
            try {
              appendScores(text);
            } catch {
              console.error('Error fetching .fqs file:', error);
              alert('Error(s) encountered. Scores may be incorrectly rendered or may not be rendered at all.');
            }
          })
          .catch(error => {
            console.error('Error fetching .fqs file:', error);
            alert('Failed to fetch the .fqs file. Please check the URL and try again.');
          });
      }
      return false;
    }

    // updateFontSizes() updates the font sizes of the various elements of
    // scores that will be rendered as SVG objects. The font default sizes are
    // specified in the style element with id 'fqs-style', but we support
    // overriding them via the bookParameters object. If the font sizes are not
    // specified in the bookParameters object, we use the default font sizes and
    // update corresponding vars in bookParameters.
    function updateFontSizes() {
      // Update the font sizes if user has specified them.
      // First, get a reference to the stylesheet,
      const stylesheet = Array.from(document.styleSheets)
        .find(sheet => sheet.href && sheet.href.includes('fqs.css'));

      console.log("Stylesheets:", document.styleSheets);
      console.log("Found stylesheet:", stylesheet);

      if (!stylesheet) {
        console.log("fqs.css stylesheet not found");
        return;
      }

      const rules = stylesheet.cssRules || stylesheet.rules;
      console.log("CSS rules:", rules);
      // define a closure that will update the font size of a rule
      // whose index is i if the font height, fh is specified in 
      // or if not specified, assign a numeric value
      // to the value in fh.
      const update = (i, fh) => {
        if (bookParameters[fh]) {
          const v = bookParameters[fh];
          rules[i].style.fontSize = v + 'px';
        } else {
          bookParameters[fh] = +rules[i].style.fontSize.slice(0, -2);
        }
      }
      // loop over the rules to update font sizes.
      for (let i = 0; i < rules.length; i++) {
        switch (rules[i].selectorText) {
          case '.title':
            update(i, "titleFontHeight")
            break;
          case '.text':
            update(i, 'textFontHeight');
            break;
          case '.preface':
            update(i, 'prefaceFontHeight');
            break;
          case '.postscript':
            update(i, 'postscriptFontHeight');
            break;
          case '.chord':
            update(i, 'chordFontHeight');
            break;
          case '.pernote':
            update(i, 'pernoteFontHeight');
            break;
          case '.fingering':
            update(i, 'fingerFontHeight');
            break;
          case '.lyric':
            update(i, 'lyricFontHeight');
            break;
          case '.pitch':
            update(i, 'pitchFontHeight');
            break;
          case '.cue':
            update(i, 'cueFontHeight');
            break;
          case '.perbar':
            update(i, 'perbarFontHeight');
            break;
          case '.perbeat':
            update(i, 'perbeatFontHeight');
            break;
          case '.counter':
            update(i, 'counterFontHeight');
            break;
          case '.rest':
            update(i, 'restFontHeight');
            break;
          case '.perline':
            update(i, 'perlineFontHeight');
            break;
          case '.lineproblem':
            update(i, 'lineproblemFontHeight');
            break;
        }
      }
    }
    // newScoreBtnsVisible() toggles the visibility of the new score buttons.  
    function newScoreBtnsVisible(visible) {
      const newScoreBtns = document.querySelectorAll('.new-score-btn');
      newScoreBtns.forEach(btn => {
        btn.style.display = visible ? 'inline-block' : 'none';
      });
    }
    // startExportButtonUpdateTimer() starts a timer that will update the
    // appearance of the export button if the score is dirty.
    function startExportButtonUpdateTimer() {
      setInterval(updateExportButtonAppearance, 500);
    }
    function updateExportButtonAppearance() {
      const exportButton = document.getElementById('exportButton');
      if (isDirty) {
        exportButton.style.backgroundColor = 'red';
        exportButton.style.color = 'white';
      } else {
        exportButton.style.backgroundColor = '';
        exportButton.style.color = '';
      }
    }

    // insertPageBreak inserts the follow content in the html document
    // with element 'el'.
    // <div style="break-after:page"></div>
    // Credit: https://stackoverflow.com/a/58245474/426853
    function insertPageBreak(el) {
      const pageBreakDiv = document.createElement('div');
      pageBreakDiv.style.breakAfter = 'page';
      el.appendChild(pageBreakDiv);
    }

    // When the window load is complete, render the scores and add listeners to
    // the buttons that invoke the functions to insert, save and delete scores.
    window.onload = () => {
      // update the stylesheet with any font sizes specified in the bookParameters object
      // We need to make sure the font size vars in bookParameters and the style rules are in sync.
      updateFontSizes();
      // Simulate click on first new score button to let user choose template
      const firstNewScoreBtn = document.getElementById('first-new-score-btn');
      firstNewScoreBtn.click();
      isDirty = false
      startExportButtonUpdateTimer();
      // toggleEdit();
    }

  </script>