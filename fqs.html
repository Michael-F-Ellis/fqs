<!DOCTYPE html>
<html>
<!--
  This file contains an HTML app for writing and rendering musical scores
  using the FQS notation system.  It defines the structure and layout of the
  score, including the placement of various elements such as title, cue, lyric,
  chord, dynamics, time signature, and pitches.

  The app uses SVG (Scalable Vector Graphics) to render the musical
  notation. The SVG elements are dynamically generated and positioned based on
  the provided musical data and configuration parameters.
  
  To understand how the app works and how the musical data is processed and
  rendered, you can refer to the following sections in the JavaScript code:

  0. The window.onload function: This function is called when the HTML file is
  loaded. It finds all the score elements (div.score) in the HTML file and
  renders them using the `renderEditedScoreSource()` function.
  
  1. The `renderScore()` function: This is the main entry point for rendering a
  score. It sets up the SVG container, applies the necessary transformations,
  and calls the respective rendering functions for each musical element class.
  
  2. The rendering functions for each musical element class (e.g.,
  Title.render(), Cue.render(), Lyric.render(), etc.): These functions handle
  the rendering of specific musical elements based on the provided data. They
  create the necessary SVG elements, set their attributes, and position them
  correctly within the score.
  
  3. The `bookParameters` object: This object contains various configuration
  parameters that control the rendering of the score, such as font heights,
  spacing, and positioning. These parameters are used throughout the rendering
  process to ensure consistent and customizable formatting. Also, see the
  <style> element in the HTML file for the CSS rules that control the formatting
  of the score.
  
  4. The `handleNewScoreButtonClick()` function: This function is called when
  the user clicks the Insert button.  It opens the dialog box for selecting a
  score template. This function is called when the user clicks the Insert
  button. It opens a dialog box where the user can choose an initial score
  template (e.g., Minimal, Full, Cheat sheet) and inserts a new score based on
  the selected template using the insertNewScore() function.
  
  5. The export() and importFromFile() functions: These functions are invoked
  by buttons in the control dropdown at the top of the page. The export
  function saves the current score data to a file and the importFromFile
  function loads a score file, splits the text into individual scores, and
  appends them to the page as separate scores.

  6. Common syntax errors in the pitch line are detected and displayed in the
  rendered output in red text below the line where the error occurred. See the
  LineProblems class and renderScore() for details. Processing continues if
  possible so that the user is not interrupted by a syntax error while
  transcribing a score.
  
  Feel free to explore the code and experiment with different musical data and
  configuration parameters to understand how the app works and how you can
  customize it to suit your needs.
-->

<head>
  <meta charset="utf-8">
  </meta>
</head>

<body>
  <details class="controls">
    <summary>
      <em>Controls</em>
    </summary>
    <button onclick="exportScores()">Export</button> <em>Save the scores from this page in <code>.fqs</code> text
      format.</em><br>
    <button onclick="importFromFile()">Import File</button> <em>Import scores from a local <code>.fqs</code>
      file.</em><br>
    <button onclick="importFromURL()">Import URL</button> <em>Import a <code>.fqs</code> file from a URL.</em><br>
  </details>
  <h3>
    Scores
  </h3>
  <div id="score-toc" class="score-toc">
  </div>
  <button class="new-score-btn" onclick="handleNewScoreButtonClick(event)">
    Insert New Score
  </button>
  <dialog id=new-score-dialog>
    <form method="dialog">
      <p>Choose an initial score template:</p>
      <label><input type="radio" name="choice" value="1" checked> Minimal</label><br>
      <label><input type="radio" name="choice" value="2"> Full</label><br>
      <label><input type="radio" name="choice" value="3"> Cheat sheet</label><br>
      <button id="cancelBtn" type="reset">Cancel</button>
      <button id="confirmBtn" type="submit">Confirm</button>
    </form>
  </dialog>
  <style id="fqs-style">
    html,
    body {
      width: 100%;
    }

    summary {
      margin-left: 5%;
    }

    img {
      margin-left: 5%;
    }

    button {
      margin: 2px;
    }

    button.new-score-btn {
      margin-left: 5%;
    }

    details.controls {
      width: 100%;
      margin-left: 0;
      margin-right: 0;
      margin-top: 2em;
      margin-bottom: 2em;
      padding-left: 5%;
    }

    div.score,
    div.score-toc {
      width: 100%;
      margin-left: 0;
      margin-right: 0;
      margin-top: 2em;
      margin-bottom: 2em;
      padding: 0;
    }

    pre.source {
      padding-left: 5%;
    }

    svg {
      /* Center the SVG element with 5% padding left, right and bottom*/
      width: 90%;
      height: 95%;
      padding-left: 5%;

    }

    /* Font sizes (adjusted dynamically at render time) */
    .lineproblem {
      font: 8px monospace;
      fill: red;
    }

    .title {
      font: 18px sans-serif;
    }

    .preface {
      font: 11px sans-serif;
    }

    .postscript {
      font: 10px sans-serif;
    }

    /* chord name, e.g. 'C' */
    .chord {
      font-family: monospace;
      font-size: 13px;
      font-style: bold;
    }

    /* chord text, e.g. 'maj7' */
    .chord-text {
      font-family: Arial, sans-serif;
      font-size: 8px;
      font-style: bold;
    }

    .grey {
      fill: rgb(160, 160, 160);
    }

    .lyric {
      font: 12px monospace;
    }

    .pitch {
      font: 12px monospace;
    }

    .pernote {
      font: 8px monospace;
      font-style: italic;
    }

    .perbar {
      font: 8px monospace;
      font-style: italic;
    }

    .perbeat {
      font: 8px monospace;
      font-style: italic;
    }

    .cue {
      /* cue text */
      fill: rgb(84, 84, 84);
      font: 8px monospace;
    }

    /* Note that the color of the text is set with the    *
       * fill property, the color property is for HTML only */
    .‚ô≠ {
      /* flat */
      fill: rgb(152, 140, 254);
      font-style: italic;

    }

    .ùÑ´ {
      /* double flat */
      fill: rgb(4, 182, 4);
      font-style: italic;
    }

    .‚ôØ {
      /* sharp */
      fill: red;
      font-style: italic;
    }

    .ùÑ™ {
      /* double sharp */
      fill: orange;
      font-style: italic;
    }

    .link-to-toc {
      /* toc links should be at the right edge of the document */
      position: absolute;
      right: 5%;

    }

    h2,
    h3,
    p,
    ul,
    ol {
      margin-left: 5%;
      margin-right: 5%;
    }
  </style>
  <script type="text/javascript">
    const bookParameters = {
      "attackNumbers": false, // (DEPRECATED) if true, attach pitch events to numbers in lyric line (useful for instrumental scores)
      "leftX": 0, // Pixel position of the left edge of the score.
      "lyricFontWidth": 7, // includes space between letters
      // Various font heights can be specified in this object to override the defaults.
      // See updateFontSizes() in this file for an explanation. Also, see the
      // style tag in this file with id "fqs-style".
    }

    // The LineProblem class holds error and warning messages generated during
    // rendering of a score. It has a render method that will render the messages
    // into the SVG element immediately below the line where the problems were
    // encountered.
    class LineProblem {
      constructor() {
        this.messages = []
      }
      add = (function (message) {
        this.messages.push(message);
      });
      clear = (function () {
        this.messages = [];
      });
      render = (function (svg, x0, y0) {
        // Draw each message in this.messages starting at x0, y0 and incrementing y
        // by bookParameters.problemFontHeight for each message.
        let y = y0;
        this.messages.forEach((function (message) {
          y += 1.1 * bookParameters.lineproblemFontHeight;
          let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", x0);
          text.setAttribute("y", y);
          text.setAttribute("class", "lineproblem");
          text.textContent = "‚ö†Ô∏è " + message;
          svg.appendChild(text);
        }));
        return y
      });
    } // end of LineProblem class 
    // instantiate a singleton LineProblem to be used by all rendering operations
    const lineProblems = new LineProblem();

    // The LyricLine class interprets the text of a lyric line and
    // and determines the location of beats, attacks and barlines.
    // It provides a render() method that will render the lyric line
    // into an svg element.
    class LyricLine {
      constructor(text) {
        this.text = text;
        // trim leading or trailing whitespace
        this.text = this.text.trim();
        // split the text on whitespace
        this.words = text.split(/\s+/);
        // join the text back together with single spaces
        this.text = this.words.join(" ");
        // Create an array of attack indices. An attack is an alpha character [a-zA-Z]
        // that is preceded by a any of the following:
        //   a space,
        //   the beginning of the text,
        //   a dash '-',
        //   a period '.', or
        //   an asterisk '*'.
        // An asterisk is also an attack
        // We also support numbers as attacks for instrumental scores
        let RGX = /[a-zA-Z]/;
        if (bookParameters.attackNumbers !== 'undefined' && bookParameters.attackNumbers === true) {
          RGX = /[a-zA-Z1-9]/; // regex for a lyric alphabetic or numeric character
        }
        // We need to store the indices of the attacks in the text as well as
        // the indices of the beats and barlines. We use these indices to
        // position pitch symbols and annotations.
        this.beats = [0,]; // beat positions
        this.bars = [0,]; // barline positions
        this.attacks = [];
        for (let i = 0; i < this.text.length; i++) {
          if (this.text[i].match(/\|/)) {
            this.bars.push(i);
            continue;
          }
          if (this.text[i].match(/\*/)) {
            this.attacks.push(i);
            continue;
          }
          if (this.text[i].match(RGX)) {
            if (i === 0) {
              this.attacks.push(i);
            } else if (this.text[i - 1].match(/[\s\-.;\*]/)) {
              this.attacks.push(i);
            }
          }
          // A beat begins with any character that is preceded by a space
          // except barline characters
          if (this.text[i].match(/\s/) && !(this.text[i + 1].match(/\|/))) {
            this.beats.push(i + 1);
          }
        }
        console.log(this.beats)
      }

      render = (function render(svg, x0, y0, fontwidth) {
        // Draw each char in this.text starting at x0, y0 and incrementing
        // x by fontwidth for each char.
        let x = x0;
        for (let i = 0; i < this.text.length; i++) {
          let char = this.text[i];
          let y = y0;
          // draw the char
          let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", x);
          text.setAttribute("y", y);
          let klass = "lyric";
          if (char == '-' || char == ';') {
            klass = "lyric grey"
          }
          text.setAttribute("class", klass);
          text.textContent = char;
          svg.appendChild(text);
          // increment x by the width of the char
          x += fontwidth;
        }
      });
    } // end of LyricLine class



    // VOffsets is a top-level object used by the Pitch class when rendering
    // pitches. The offsets are fractions of the font height.
    // where h is the font height.  Note that svg coordinates increase from
    // the top of the viewport, hence the reverse ordering for the 12 pitch
    // classes. The letter 'f' is empiricaly lowered .6 units to make it
    // appear a little lower than 'g', i.e. to compensate for the visual
    // effect of 'g's descender.
    const vOffsets = {
      "ùÑ™a": 1, "‚ôÆb": 1, "‚ô≠c": 13,   // B enharmonics (special case for C‚ô≠)
      "‚ôØa": 2, "‚ô≠b": 2, "ùÑ´c": 14,   // B-flat enharmonics (special case for CùÑ´)
      "ùÑ™g": 3, "‚ôÆa": 3, "ùÑ´b": 3,    // A enharmonics
      "‚ôØg": 4, "‚ô≠a": 4,              // A-flat enharmonics
      "ùÑ™f": 5.6, "‚ôÆg": 5, "ùÑ´a": 5,    // G enharmonics
      "ùÑ™e": 6, "‚ôØf": 6.6, "‚ô≠g": 6,    // G-flat enharmonics
      "‚ôØe": 7, "‚ôÆf": 7.6, "ùÑ´g": 7,     // F enharmonics
      "ùÑ™d": 8, "‚ôÆe": 8, "‚ô≠f": 8.6,     // E enharmonics
      "‚ôØd": 9, "‚ô≠e": 9, "ùÑ´f": 9.6,    // E-flat enharmonics
      "ùÑ™c": 10, "‚ôÆd": 10, "ùÑ´e": 10, // D enharmonics
      "ùÑ™b": -1, "‚ôØc": 11, "‚ô≠d": 11, // D-flat enharmonics
      "‚ôØb": 0, "‚ôÆc": 12, "ùÑ´d": 12, // C enharmonics
    }

    // keyTable maps a key signature to a table of accidentals for each pitch class.
    // Key signatures are specified as a string containing a number of sharps or flats,
    // e.g. "0" for C major, "#1" for G major, "#2" for D major, etc. For flats, the key sig
    // looks like "&1", for F major, "&2" for B-flat major, etc.
    const keyTable = {
      "0": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#1": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#2": { "c": "‚ôØ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#3": { "c": "‚ôØ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#4": { "c": "‚ôØ", "d": "‚ôØ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#5": { "c": "‚ôØ", "d": "‚ôØ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôØ", "b": "‚ôÆ" },
      "#6": { "c": "‚ôØ", "d": "‚ôØ", "e": "‚ôØ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôØ", "b": "‚ôÆ" },
      "#7": { "c": "‚ôØ", "d": "‚ôØ", "e": "‚ôØ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôØ", "b": "‚ôØ" },
      "&1": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ô≠" },
      "&2": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ô≠" },
      "&3": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ô≠", "b": "‚ô≠" },
      "&4": { "c": "‚ôÆ", "d": "‚ô≠", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ô≠", "b": "‚ô≠" },
      "&5": { "c": "‚ôÆ", "d": "‚ô≠", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ô≠", "a": "‚ô≠", "b": "‚ô≠" },
      "&6": { "c": "‚ô≠", "d": "‚ô≠", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ô≠", "a": "‚ô≠", "b": "‚ô≠" },
      "&7": { "c": "‚ô≠", "d": "‚ô≠", "e": "‚ô≠", "f": "‚ô≠", "g": "‚ô≠", "a": "‚ô≠", "b": "‚ô≠" },
    }
    // The Alterations class is used to manage the alterations for a given key signature
    // and to keep track of which pitches have been explicitly altered within a bar.
    class Alterations {
      constructor(keysym) {
        this.keyLUT = keyTable[keysym];
        // We allow for incomplete key signatures to avoid raising errors
        // while the user is typing.  If the key signature is invalid, we
        // set the key to "0" (C major) and log a warning.
        if (this.keyLUT === undefined) {
          this.keyLUT = keyTable["0"];
          lineProblems.add("invalid or incomplete keysym: " + keysym);
        }
        this.altered = {}
      }
      setKey = () => {
        this.keyLUT = keyTable[keysym];
      }
      initAltered = () => {
        this.altered = {};
      }
      get = (pitchSym, octave, alteration) => {
        // if alteration is not "?", update the altered table entry with the new
        // alteration and return the alteration
        const pitch = pitchSym + octave;
        if (alteration !== "?") {
          this.altered[pitch] = alteration;
          return alteration
        }
        // Otherwise, the value '?' means we need to look up the pitch in the altered
        // table to see if it has a prior alteration. If it does, return that, otherwise
        // look it up in keyLUT and return the value from that.
        if (this.altered[pitch] !== undefined) {
          return this.altered[pitch];
        }
        return this.keyLUT[pitchSym];
      }
    } // end of Alterations class

    // The Pitch class is used to render a single pitch. It is instantiated with a
    // letter, octave and accidental class. The accidental class is a UTF-8 character
    // for natural, sharp, flat, double-sharp or double-flat. The render() method
    // draws the pitch letter at the proper x, y location within the svg with the
    // color and font specified in the style sheet for its accidental class.
    class Pitch {
      constructor(letter, octave, accidentalClass, fontheight) {
        this.letter = letter;
        this.octave = octave; // octave is an offset relative to a center octave whose value is 0
        this.accidentalClass = accidentalClass; // one of '', 'ùÑ´', '‚ôØ', 'ùÑ™' or ''
      }
      render = (function render(svg, x, y, fontheight) {
        // Draw the pitch at the specified x, y coordinates.
        let pitch = document.createElementNS("http://www.w3.org/2000/svg", "text");
        pitch.setAttribute("x", x);
        pitch.setAttribute("class", "pitch " + this.accidentalClass);
        pitch.textContent = this.letter;
        // Adjust the y coordinate by the octave and vertical offset for this pitch
        y -= this.octave * fontheight;
        y += vOffsets[this.accidentalClass + this.letter] * (fontheight / 12);
        pitch.setAttribute("y", y);
        svg.appendChild(pitch);
      });
    }
    // The PitchLine class is used to render a single line of pitches from a
    // text string.  This is the most complicated class in the program as it
    // must handle octavation, key signatures, accidentals and alterations and
    // match each pitch to its corresponding attack location in the Lyric line.
    class PitchLine {
      constructor(text) {
        this.centerOctave = 0;
        this.text = text;
        // trim leading or trailing whitespace
        this.text = this.text.trim();
        // split the text on whitespace
        this.beatTokens = text.split(/\s+/);
        // A beat token may contain one or pitch tokens, e.g "c^&d&e"
        // We need to split these into individual pitch tokens. A pitch
        // token is zero or more of [^/] followed by zero or more of [#&%]
        // followed by exactly one of [a-g]. So, for example, "c^&d//&e"
        // would be split into ["^c", "&d", "//&e"]. It's permissible, but
        // not required, to include bar lines in the source to make it a little
        // easier to read and edit. However, omitting bar lines may result
        // in accidentals propagating beyond the bar lines defined in the lyric line.
        this.tokens = [];
        for (let i = 0; i < this.beatTokens.length; i++) {
          let beatToken = this.beatTokens[i];
          // Handle key designator of the form "K[#&]?[0-7]".
          // The key designator is optional, so if it's not there, we'll just
          // use the default key of C major.

          if (beatToken.match(/K.*/)) {
            this.tokens.push(beatToken);
            continue
          }
          if (beatToken.match(/:*\|:*/)) {
            this.tokens.push(beatToken);
            continue
          }
          // If the beat token is empty, just skip it.
          if (beatToken.length === 0) {
            continue;
          }
          // Now we split the beat token into individual pitch tokens.
          let pitchToken = "";
          for (let j = 0; j < beatToken.length; j++) {
            if (beatToken == '|' || beatToken == '|:' || beatToken[j] == ':|') {
              this.tokens.push(beatToken)
            } else if (beatToken[j].match(/[\^\/]/)) {
              pitchToken += beatToken[j];
            } else if (beatToken[j].match(/[#&%]/)) {
              pitchToken += beatToken[j];
            } else if (beatToken[j].match(/[a-g]/)) {
              pitchToken += beatToken[j];
              this.tokens.push(pitchToken);
              pitchToken = "";
            } else {
              //throw new Error("Invalid pitch token: " + beatToken);
              lineProblems.add("Invalid pitch token: " + beatToken);
            }
          }
        }


        // Next we parse the tokens into an array of pitch objects.
        // The octave of each pitch depends on the prior pitch. To
        // begin, we let the prior pitch be C natural on the center
        // octave.
        let prevPitch = new Pitch("c", this.centerOctave, "");
        // A pitch token always ends with a letter in [a-g].
        // It may optionally be preceded by at most one of the following accidentals
        // "##", "&&", "#", "&", or '%'.
        // where ## is double-sharp, && is double-flat, # is sharp, and & is flat.
        // The accidentals and letter are optionally preceded by octavation marks, `^ ` and ` / `.
        // It is an error to mix '^`' and ' / ' in a single pitch token. It is also an
        // error if the octave marks cause the new octave be less than -3 or greater than 3.
        // The following are all valid pitch tokens:
        // 'g', '#f', '^b', '//&d', '&&f'
        // The following are all invalid pitch tokens:
        // 'h', '###f', '#&g', '^/a'
        this.pitches = [];
        this.alterations = new Alterations("0"); // default key is C major
        for (let i = 0; i < this.tokens.length; i++) {
          // Handle key designator of the form "K(0|[#&]?[1-7])".
          if (this.tokens[i].match(/K/)) {
            this.alterations = new Alterations(this.tokens[i].slice(1));
            continue;
          }
          // first, get the pitch letter from the token
          // it's the last char in the token. It's an error if the token is empty
          // or if the token does not end with a letter in [a-g]
          let token = this.tokens[i];
          if (token.length === 0) {
            // throw new Error("Empty pitch token");
            lineProblems.add("Empty pitch token");
          }
          if (token == "|" || token == "|:" || token == ":|") {
            this.alterations.initAltered();
            continue
          }
          let letter = token[token.length - 1];
          if (!letter.match(/[a-g]/)) {
            // throw new Error("Invalid pitch token: " + token);
            lineProblems.add("Invalid pitch token: " + token);
          }
          // Next we compare the pitch letter to the previous pitch
          // letter and apply the Lilypond rule of fourths to
          // determine if the pitch will be above or below the
          // previous pitch. The rule of fourths is a way to default
          // to the closest pitch to the previous one. It states that
          // we must choose the pitch which is within a musical 4th of
          // the previous pitch.  Thus, if the previous pitch is 'g'
          // in octave 4 and the current pitch letter is 'f', we
          // should choose the 'f' in octave 4 rather than 'f' in
          // octave 5.  Similarly if the previous pitch is 'g' in
          // octave 4 and the current pitch letter is 'c', we should
          // choose the 'c' in octave 5 rather than 'c' in octave 4
          // because that is the closest.

          // get the pitch letter of the previous pitch
          let prevLetter = prevPitch.letter;
          // get the octave of the previous pitch
          let prevOctave = prevPitch.octave;
          // Make a map of pitch letters:
          let PitchMap = new Map([
            ["c", 0],
            ["d", 1],
            ["e", 2],
            ["f", 3],
            ["g", 4],
            ["a", 5],
            ["b", 6]
          ]);
          // get the pitch letter index of the previous pitch
          let prevLetterIndex = PitchMap.get(prevLetter);
          // get the pitch letter index of the current pitch
          let letterIndex = PitchMap.get(letter);
          // Subtract the indices
          let diff = letterIndex - prevLetterIndex;
          // If the difference is positive and less than 4, the current pitch is
          // above the previous pitch in the same octave. If the difference is positive
          // and greater than 3, the current pitch is below the previous pitch in the next octave down.
          let octave = prevOctave;
          if (diff > 0 && diff > 3) {
            // the current pitch is below the previous pitch in the next octave down
            // so decrement the octave
            octave--;
          } else if (diff < 0 && diff < -3) {
            // the current pitch is above the previous pitch in the previous octave up
            // so increment the octave
            octave++;
          }
          // Now we must account for octave marks, if any.	
          let kind = "";
          let j = 0;
          let done = false;
          while (j < token.length) {

            switch (token[j]) {
              case "^":
                if (kind === "/") {
                  // throw new Error("Invalid pitch token: " + token);
                  lineProblems.add("Invalid pitch token: " + token);
                }
                octave++;
                kind = "^";
                break;
              case "/":
                if (kind === "^") {
                  // throw new Error("Invalid pitch token: " + token);
                  lineProblems.add("Invalid pitch token: " + token);
                }
                octave--;
                kind = "/";
                break;
              default:
                done = true;
                break;
            }
            if (done) break;
            j++;
          }
          // Index j now points to the first accidental, if any
          kind = null;
          let count = 0;
          while (j < token.length && token[j].match(/[#&%]/)) {
            if (token[j] === "#") {
              if (kind === "&" || kind === "%") {
                //throw new Error("Invalid pitch token: " + token);
                lineProblems.add("Invalid pitch token: " + token);
              }
              kind = "#";
              count++;
            } else if (token[j] === "&") {
              if (kind === "#" || kind === "%") {
                //throw new Error("Invalid pitch token: " + token);
                lineProblems.add("Invalid pitch token: " + token);
              }
              kind = "&";
              count++;
            } else if (token[j] === "%") {
              if (kind === "#" || kind === "&") {
                //throw new Error("Invalid pitch token: " + token);
                lineProblems.add("Invalid pitch token: " + token);
              }
              kind = "%";
              count++;
            }
            j++
          }
          if (count > 2) {
            //throw new Error("Invalid pitch token: " + token);
            lineProblems.add("Invalid pitch token: " + token);
          }
          // Use kind and count to assign an accidental class, the create a new pitch object
          // and add it to the pitches array and designate it as the new previous pitch.
          let accClass = null;
          switch (kind) {
            case "#":
              if (count === 1) {
                accClass = "‚ôØ"; // sharp
              } else {
                accClass = "ùÑ™"; // double sharp
              }
              break;
            case "&":
              if (count === 1) {
                accClass = "‚ô≠"; // flat
              } else {
                accClass = "ùÑ´"; // double flat
              }
              break;
            case "%":
              accClass = "‚ôÆ"; // natural
              break;
            default:
              accClass = "?"; // to be determined
          }
          // TODO deal properly with key signatures and persistence of
          // accidentals for remainder of the bar.
          accClass = this.alterations.get(letter, octave, accClass);
          this.pitches.push(new Pitch(letter, octave, accClass));
          // console.log(letter, octave, accClass)
          prevPitch.letter = letter;
          prevPitch.octave = octave;
        }
      }
      render = (function (svg, x0, y0, attacks, fontwidth, fontheight, bars) {
        // x0 is the x coordinate of the left edge of the line
        // y0 corresponds to the baseline of the center octave (0)
        // Experimental: draw a thin gray horizontal lines at the base of 'c' in each octave
        const yline0 = y0 + 2 * fontheight;
        const yline1 = yline0 - fontheight
        const yline2 = yline1 - fontheight
        const yline3 = yline2 - fontheight
        const xend = fontwidth * (1 + bars[bars.length - 1]); // extend line to last barline
        for (let y of [yline0, yline1, yline2, yline3]) {
          let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", x0);
          line.setAttribute("y1", y);
          line.setAttribute("x2", xend);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", "lightgray");
          line.setAttribute("stroke-width", 0.5);
          svg.appendChild(line);
        };
        // Now draw barlines
        for (let n of bars) {
          if (n === 0) continue;
          let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          let x = x0 + (n + 0.5) * fontwidth;
          line.setAttribute("x1", x);
          line.setAttribute("y1", yline3);
          line.setAttribute("x2", x);
          line.setAttribute("y2", yline0);
          line.setAttribute("stroke", "lightgray");
          line.setAttribute("stroke-width", 0.5);
          svg.appendChild(line);
        }

        // Loop through the pitches and render them at the corresponding 
        // attack locations. It is not an error if the number of pitches
        // is not equal to the number of attack locations because we may
        // be updating the rendered pitches while the user is editing.
        let i = 0;
        for (let pitch of this.pitches) {
          let x = x0;
          let y = y0;
          if (i < attacks.length) {
            x = x0 + attacks[i] * fontwidth;
            pitch.render(svg, x, y, fontheight);
          }
          i++;
        }

      });
    };

    // The Cue class is used render cue text in the style specified in the style sheet.
    class Cue {
      constructor(text) {
        this.text = text;
      }
      render = (function (svg, x0, y0) {
        // x0 is the x coordinate of the left edge of the line
        // y0 is the y coordinate of the base line of the cue
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", x0);
        text.setAttribute("y", y0);
        text.setAttribute("class", "cue");
        text.textContent = this.text;
        svg.appendChild(text);
      });
    } // end Cue class

    // The Expression class is used to render musical expressions, e.g. "cresc.", "mf", etc
    // Expressions are rendered by looping through the tokens and rendering each one
    // at the next attack from the lyric line.
    class PerNote {
      constructor(text) {
        this.text = text;
        // Trim the text and split on whitespace
        this.tokens = this.text.trim().split(/\s+/);
      }
      render = (function (svg, x0, y0, attacks, fontwidth) {
        // x0 is the x coordinate of the left edge of the line
        // y0 is the y coordinate of the baseline of the line
        // fontwidth is the width of the lyric font in pixels.
        // (the expression font will typically be smaller than the lyric font)
        // As with the Pitch class, we will render the expression
        // by looping through the tokens and rendering each one
        // at the next attack from the lyric line. As a special
        // case, if the expression text begins with a number, it
        // is taken to be a measure number and is rendered at x0
        // regardless of whether an attack exists at that position.
        // This introduces some annoying bookkeeping as we have to
        // track the width of the measure number to avoid overwriting
        // it is there is an attack at the beginning of the line.

        const mm = parseInt(this.tokens[0]);
        if (!isNaN(mm)) {
          const w = (1 + mm.toString().length) * fontwidth;
          const attack0x = attacks[0] * fontwidth;
          if (attack0x >= w) {
            // insert an attack at 0 to render the measure number
            attacks.splice(0, 0, 0);
          }
        }
        let i = 0;
        for (let token of this.tokens) {
          let x = x0;
          let y = y0;
          if (i < attacks.length) {
            x = x0 + attacks[i] * fontwidth;
            let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.setAttribute('class', 'pernote');
            // replace any underscores with spaces
            text.textContent = token.replace(/_/g, " ");
            svg.appendChild(text);
          }
          i++;
        }
      })
    } // end of Expression class

    // The PerBar class is used to render time signatures or other per bar information.
    class PerBar {
      constructor(text) {
        this.text = text;
        // split the text on whitespace
        this.tokens = this.text.split(/\s+/);
      }
      render = (function (svg, x0, y0, bars, fontwidth) {
        // x0 is the x coordinate of the left edge of the line y0 is the
        // y coordinate of the baseline of the line. Bars is an array of
        // bar line position.  fontwidth is the width of the lyric font
        // in pixels.  (the time signature font will typically be
        // smaller than the lyric font) Similarly to the Expression
        // class, we will render the expression by looping through the
        // tokens and rendering each one at the next bar. We use the
        // under score character to skip barlines. Thus, `4/4 _ 3/4`
        // will render a 4/4 time signature at the beginning of the line
        // (position 0) and a 3/4 time signature above the barline at
        // position the beginning of the third bar in the line.

        let i = 0;
        for (let token of this.tokens) {
          let x = x0;
          let y = y0;
          if (i < bars.length) {
            x = x0 + bars[i] * fontwidth;
            let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.setAttribute('class', 'perbar');
            // replace any underscores with spaces
            text.textContent = token.replace(/_/g, " ");
            svg.appendChild(text);
          }
          i++;
        }
      })
    }

    // The PerBeatclass is used to render annotations that map to beats.
    class PerBeat {
      constructor(text) {
        this.text = text;
        // split the text on whitespace
        this.tokens = this.text.split(/\s+/);
      }
      render = (function (svg, x0, y0, beats, fontwidth) {
        // x0 is the x coordinate of the left edge of the line y0 is the
        // y coordinate of the baseline of the line. Bars is an array of
        // bar line position.  fontwidth is the width of the lyric font
        // in pixels.  (the perbeat font will typically be
        // smaller than the lyric font) Similarly to the PerBar
        // class, we will render the expression by looping through the
        // tokens and rendering each one at the next beat.

        let i = 0;
        for (let token of this.tokens) {
          let x = x0;
          let y = y0;
          if (i < beats.length) {
            x = x0 + beats[i] * fontwidth;
            let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.setAttribute('class', 'perbeat');
            // replace any underscores with spaces
            text.textContent = token.replace(/_/g, " ");
            svg.appendChild(text);
          }
          i++;
        }
      })
    }
    // The Chord class is used to render chords symbols above beats.
    class Chord {
      constructor(text) {
        this.text = text;
        // Trim the text and split on whitespace
        this.tokens = this.text.trim().split(/\s+/);
        // Replace common abreviations with symbols, e.g. "maj" with "‚ñ≥"
        // so that, for example, "Cmaj7" will render as "C‚ñ≥7"
        this.tokens = this.tokens.map(token => {
          return token.replace(/m7b5/, "√∏7")
            .replace(/-7b5/, "√∏7")
            .replace(/maj7/, "‚ñ≥7")
            .replace(/min/, "m")
            .replace(/m/, "m")
            .replace(/dim/, "¬∞")
            .replace(/aug/, "+")
            .replace(/7b9/, "7‚ô≠9")
            .replace(/b/, "‚ô≠")
            .replace(/#/, "‚ôØ")
            .replace(/\//, "/")
        });
      }
      render = (function (svg, x0, y0, beats, fontwidth) {
        // x0 is the x coordinate of the left edge of the line
        // y0 is the y coordinate of the baseline of the line
        // fontwidth is the width of the lyric font in pixels.
        // (the chord font will typically be larger than the lyric font)
        // As with the Pitch class, we will render the expression
        // by looping through the tokens and rendering each one
        // at the next beat from the lyric line. Before rendering,
        // we split the chord tokens into the root and the chord text,
        // e.g. "Cmaj7" will be split into ["C", "maj7"]. The chord
        // text is rendered in a smaller font than the root.
        // Note, at present I'm using a couple of fudge factors to
        // get the chord text to render correctly. This is not ideal
        // and should be replaced with a more robust solution.
        const xfudge = 1.2 * fontwidth // px
        const yfudge = 4 // px
        let i = 0;
        for (let token of this.tokens) {
          const root = token[0]
          const chtext = token.slice(1)
          let x = x0;
          let y = y0;
          if (i < beats.length) {
            x = x0 + beats[i] * fontwidth;
            let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.setAttribute('class', 'chord');
            // replace any underscores with spaces
            text.textContent = root.replace(/_/g, " ");
            svg.appendChild(text);
            if (root != "_") {
              x += xfudge;
              let text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              text2.setAttribute('x', x);
              text2.setAttribute('y', y - yfudge);
              text2.setAttribute('class', 'chord-text');
              text2.textContent = chtext
              svg.appendChild(text2);
            }
          }
          i++;
        }
      })
    }
    // splitFirst splits a string on the supplied separator and returns
    // a two-element array of strings containing the part that preceded the
    // separator and the remainder of the string, e.g.
    //   splitFirst('foo: bar: blah, blah', ': ') --> ['foo', 'bar: blah, blah']
    // If the separator is not present, splitFirst returns an empty string
    // for the first element and the entire string as the remainder, e.g.
    //   splitFirst('no colons here', ': ') --> ['', 'no colons here']
    function splitFirst(str, separator) {
      const separatorIndex = str.indexOf(separator);
      if (separatorIndex === -1) {
        return ["", str];
      }
      return [str.slice(0, separatorIndex), str.slice(separatorIndex + separator.length)];
    }

    // musicToPitchLyric takes a music line (a string) and returns a pitch line  and a
    // lyric line as an object. For example, if the music line is `K#2 c; d -e f |` the
    // lyric line will be `*; * -* * |` and the pitch line will be 
    // `K#2 c d e f |`. 
    //
    // The lyric line is constructed by identifying all key signature
    // and pitch tokens in the music and removing the key signatures and
    // replacing the pitch tokens with asterisks.
    //
    // The pitch line is constructed by removing all the hold or rest
    // characters, '-' and ';'the from music line. 
    function musicToPitchLyric(musicLine) {
      let lyricLine = musicLine;
      let pitchLine = musicLine;

      // Remove key signatures and replace pitch tokens with asterisks in the lyric line
      lyricLine = lyricLine.replace(/K[#&]?\d/g, "").replace(/\^*\/*[#&%]*[a-g]/g, "*");

      // Remove hold and rest characters from the pitch line
      pitchLine = pitchLine.replace(/[-;]/g, "");

      return {
        lyric: lyricLine.trim(),
        pitch: pitchLine.trim()
      };
    }

    // The preprocessScore function is used to parse the score input
    // text and convert it into a data object with members for the title,
    // preface, lyrics, expressions, cues, pitches, chords, perbars and
    // postscript. The data object is returned.
    // It's important to understand the distinction between line groups
    // and singleton lines. A line group is a group of lines that represent
    // a line of music.  Singletons are things like title, preface, etc.
    // that appear once within a score. Within the score text, blank lines
    // i.e. /\n\s*\n/ are delimeters between singletons and line groups.
    function preprocessScore(text) {
      const lineGroups = text.split(/\n\s*\n/);
      console.log(lineGroups);
      let kvlines = lineGroups.map(line => {
        const parts = line.split(/\n/);
        const obj = {};
        parts.forEach(part => {
          part.trim()
          const [key, value] = splitFirst(part, ': ');
          k = key.trim();
          if (k !== "" && value !== undefined) {
            obj[k] = value.trim();
          }
        });
        return obj;
      });
      kvlines = kvlines.filter(obj => Object.keys(obj).length > 0);
      console.log(kvlines);
      const data = { text: text, lines: [] };

      // loop over kvlines and assign each member to data.
      for (let kv of kvlines) {
        if (Object.keys(kv).length > 1) {
          // It's a line group. Push it onto the lines array.
          data.lines.push(kv);
          continue;
        }
        // Handle objects with only one key. Title, preface, postscript and
        // zoom are singletons. We allow individual instance of cue, music, and
        // lyric to be rendered as line groups.
        for (let key in kv) {
          switch (key) {
            case "cue":
            case "music":
            case "lyric":
              // all 3 above are allowed as line groups of length 1.
              data.lines.push(kv);
              break;
            case "title":
              data.title = kv[key];
              break;
            case "preface":
              data.preface = kv[key];
              break;
            case "postscript":
              data[key] = kv[key];
              break;
            case "zoom":
              data.zoom = kv[key];
              break;
            default:
              console.log("Unknown key: " + key);
          }
        }
      }
      return data;
    }

    // The renderScore function is used to render the score using the
    // members of the data object created by preprocessScore.
    //  - svg is an svg element
    //  - data is an object containing the score
    function renderScore(svg, data) {
      // clear any existing content of the SVG element
      svg.innerHTML = "";

      let y = 0; // y coordinate of the top of the rendered score

      // Render any line problems that were encountered in
      // preliminary processing
      y = lineProblems.render(svg, bookParameters.leftX, y);
      lineProblems.clear();

      // Render the title at the top of the SVG element
      y += 2 * bookParameters.titleFontHeight
      const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      title.setAttribute('x', bookParameters.leftX);
      title.setAttribute('y', bookParameters.titleFontHeight);
      title.setAttribute('class', 'title');
      title.textContent = data.title;
      svg.appendChild(title);
      // y += 0.5 * bookParameters.titleFontHeight

      // Render the preface, if any
      if (data.preface) {
        const preface = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        preface.setAttribute('x', bookParameters.leftX);
        preface.setAttribute('y', y);
        preface.setAttribute('class', 'preface');
        preface.textContent = data.preface;
        svg.appendChild(preface);
        y += 2 * bookParameters.pernoteFontHeight;
      }
      // Render the score
      data.lines.forEach((line, index) => {
        // Handle the music lines. If present, a music line replaces the
        // lyric and pitch lines.
        if (line.music) {
          const { lyric, pitch } = musicToPitchLyric(line.music);
          line.lyric = lyric;
          line.pitch = pitch;
        }
        let lyricline = undefined
        if (line.lyric) {
          lyricline = new LyricLine(line.lyric);
        }
        y += bookParameters.lyricFontHeight
        // Render the cue, if any
        if (line.cue) {
          if (!line.lyric) {
            y += 1.5 * bookParameters.lyricFontHeight;
          } else {
            y += bookParameters.lyricFontHeight;
          }
          const cue = new Cue(line.cue);
          cue.render(svg, bookParameters.leftX, y);
        }
        // Render the chords, if any
        if (line.chord && line.lyric) {
          y += bookParameters.chordFontHeight
          const chord = new Chord(line.chord);
          chord.render(svg, bookParameters.leftX, y, lyricline.beats, bookParameters.lyricFontWidth);
          // y += bookParameters.chordFontHeight / 3;
        }
        // Render per-beat items, if any
        if (line.perbeat && line.lyric) {
          y += bookParameters.perbeatFontHeight * 1.5
          const perbeat = new PerBeat(line.perbeat)
          perbeat.render(svg, bookParameters.leftX, y, lyricline.beats, bookParameters.lyricFontWidth)
        }

        // Render the pitches, if any
        if (line.pitch && line.lyric) {
          y += 1.5 * bookParameters.lyricFontHeight;
          try {
            const pitchLine = new PitchLine(line.pitch);
            pitchLine.render(svg, bookParameters.leftX, y, lyricline.attacks, bookParameters.lyricFontWidth, bookParameters.lyricFontHeight, lyricline.bars);
            y += 2 * bookParameters.lyricFontHeight;
          } catch (e) {
            lineProblems.add("Pitch line error: " + e.message);
            console.log(e);
          }
        }
        if (line.perbar && line.lyric) {
          y += bookParameters.perbarFontHeight;
          const perbar = new PerBar(line.perbar);
          perbar.render(svg, bookParameters.leftX, y, lyricline.bars, bookParameters.lyricFontWidth);

        }
        // Render the lyric
        y += 1.1 * bookParameters.lyricFontHeight;
        if (line.lyric) {
          lyricline.render(svg, bookParameters.leftX, y, bookParameters.lyricFontWidth);
        }

        // Render the per note expression marks, if any.
        if (line.pernote && line.lyric) {
          y += bookParameters.pernoteFontHeight * 1.5; // 2 px extra space between exprs and lyric to clear descenders
          const expr = new PerNote(line.pernote);
          expr.render(svg, bookParameters.leftX, y, lyricline.attacks, bookParameters.lyricFontWidth);
        }
        // Render any line problems that were encountered
        y = lineProblems.render(svg, bookParameters.leftX, y);
        lineProblems.clear();
      });

      // Render the postscript, if any.
      if (data.postscript) {
        y += 2 * bookParameters.lyricFontHeight;
        const postscript = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        postscript.setAttribute('x', bookParameters.leftX);
        postscript.setAttribute('y', y);
        postscript.setAttribute('class', 'postscript');
        postscript.textContent = data.postscript;
        svg.appendChild(postscript);
        y += bookParameters.pernoteFontHeight;
      }
    }

    // deleteScore(id) deletes the score div with the given id and all its
    // content from the DOM along with the Insert button that follows it.
    function deleteScore(id) {
      const score = document.getElementById(id);
      if (score === null) {
        return
      }
      score.remove();
      btnId = "insert-new-" + id;
      const insertButton = document.getElementById(btnId);
      if (insertButton !== null) {
        insertButton.remove();
      }
      scoreToc(); // update the table of contents
    }

    // renderEditedScoreSource takes as its argument a div element. If the div element
    // contains a <pre> of class 'source', the contents of the <pre> are passed
    // preprocessScore() and the result is used as the data argument to renderScore().:
    // If the div already contains an SVG element, it is passed to renderScore() as
    // the svg argument. Otherwise, a new SVG element is created and appended to the
    // to the div element and passed to renderScore().
    function renderEditedScoreSource(div) {
      const pre = div.querySelector('details pre.source');
      if (pre === null) {
        return
      }
      const data = preprocessScore(pre.textContent);
      let svg = div.querySelector('svg');
      if (svg === null) {
        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        div.insertBefore(svg, div.firstChild);
      }
      renderScore(svg, data);
      // calculate rendered height and adjust the svg height and viewbox
      const height = svg.getBBox().height + 20;
      svg.setAttribute('height', height);
      let zoom = 100;
      if (data.zoom) {
        // if data.zoom can't be parsed, use 100% and add a message to the
        // lineProblems object so that the error can be displayed in the
        // SVG.
        zoom = parseInt(data.zoom, 10);
        if (isNaN(zoom)) {
          lineProblems.add("Invalid zoom value: " + data.zoom);
          zoom = 100;
        }
        // allow user to specify a zoom factor between 50 and 200%
        zoom = Math.max(50, Math.min(200, parseInt(zoom, 10)));
      }
      const xpix = 720 * 100. / zoom;
      svg.setAttribute('viewBox', `0 0 ${xpix} ${height}`);
      scoreToc(); // update the table of contents
    }
    // scoreToc is a function that generates a table of contents for the scores in the
    // current page. It creates a ul element that contains li elements for each score.
    // Each li element contains a link to the score's div element. The link text is the
    // title of the score. The title is extracted from the first line of the score's
    // source. The ul is inserted into the div with id'score-toc'.
    function scoreToc() {
      let toc = document.getElementById('score-toc');
      // if score-toc div doesn't exist, create it as the first
      // child of body
      if (toc === null) {
        const body = document.querySelector('body');
        toc = document.createElement('div');
        toc.id = 'score-toc';
        body.insertBefore(toc, body.firstChild);
      } else {
        toc.innerHTML = ''; // Clear it
      }
      const scores = document.querySelectorAll('div.score');
      if (scores.length === 0) {
        return;
      }
      const ul = document.createElement('ul');
      for (const score of scores) {
        const text = score.querySelector('details pre.source').textContent.split('\n');
        // find the title line of the score's source
        const titleline = text.find(line => line.trim().startsWith('title:'));
        const title = titleline.split(':')[1].trim();
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.setAttribute('href', `#${score.id}`);
        a.textContent = title;
        li.appendChild(a);
        ul.appendChild(li);
      }
      // insert the ul of score links into the toc div
      toc.appendChild(ul);
      return;
    }

    function newScoreContent(intChoice) {
      const choices = {
        minimal: `title: Title?

lyric: * * * * |
pitch: K0 cdef |

`,

        full: `title: My Score Title

preface: This score has it all

cue: This cue stands apart

cue: This cue attaches to the notation
chord: Cmaj7 _ Dm7
perbeat: 1 2 3 4
pitch: K0 c d e f |
perbar: 4/4
lyric: do re mi fa |
pernote: mf


postscript: The postscript line is handy for copyright notices, etc.`,

        cheatsheet: `: Lines that start with a colon are comments. They don't appear in the rendered score.
: See the comments at the bottom this example score.        

title: Cheat Sheet

preface: This score has it all

cue: This cue stands apart

cue: This cue attaches to the notation
chord: Cmaj7 _ Dm7 _ G7 _ Cmaj7
perbeat: 1 2 3 4
pitch: K0 c d e f | g a b c |
perbar: 4/4
lyric: do re mi fa | so la ti do |
pernote: mf

cue: Second line of music
chord: Dmaj7 _ Em7 _ A7 _ Dmaj7
perbeat: 1 2 3 4
pitch: K#2 defg | abcd |
perbar: 4/4
lyric: * * * * | * * * * |
pernote: mf

: The structure of an FQS score is:
      : 1. A title,
      : 
 .    : 2. An optional preface line of text,
      : 
      : 3. One of more groups of lines of music lines and cues lines,
      :
      : 4. An optional postscript line of text

: Empty lines are significant:
      : At least one after the title and after the preface.
      : At least one between groups of lines of music and cues.
      : None between components of music line groups.
      : At least one before the postscript.

: Music line groups:
      : A music line group refers to a group of lyric, pitch and annotation lines.
      : Together, they tell FQS how to render a single line of music.

: Lyric lines:
      : define the rhythm using the following characters.
      : Attack: '*' or a syllable of alphabetic characters.
      : Sustain: '-' continues the note from the prior attack.'
      : Rest: ';' semicolon
      : Whitespace: ' ' separates beats.
      : Syllable Separator: '.' (period) separates syllables that fall in the same beat.
      :                     | This is four beats | Four.six.teenth.notes  a.trip.let  two.eighths  ; |
      : Barline: '|' separates measures.

: Pitch lines:
      : contain pitches, key signatures and barlines.
      : Pitch examples:
          :'c'    C, octave nearest to prior pitch, alteration determined by key signature or prior alteration
          :'#d'   D-sharp, octave as above
          :'##e'  E-double-sharp, octave as above
          :'&f'   F-flat, octave as above
          :'&&g'  G-double-flat, octave as above
          :'/&a'  A-flat one octave lower
          :'^&b'  B-flat one octave higher
          :'//#c' C-sharp, two octaves lower
      : Octave marks and accidentals PRECEDE the pitch, so '/#c', NOT '/c#'' or 'c#/''
      : Whitespace is NOT signifcant between pitches. 'c d e f' is the same as 'cdef'
      : Barlines: Needed so altered pitches cancel at end of measure.
      : Key signatures: 'K0' or K#|&[1-7], i.e. 'K0' = C major, 'K#1' = G major, 'K#2' = D major, 'K&1' = F major, etc.
          
: Annotations (all optional):
        : cue: A line of text you want to appear as a cue.
        :      cues may be attached to the notation or stand alone if followed by a blank line.
        : chord: chord symbols aligned to beats
        : perbar: Items aligned to barlines, e.g. time signatures
        : perbeat: Items aligned to beats, e.g. tempo markings
        : pernote: Items aligned to attacks, e.g. dynamic markings

: Underscores '_' are used to skip beats, barlines, or attacks in annotations.
        : e.g. 'perbar: 4/4 _ 3/4' puts 4/4 at the first measure and 3/4 at the third measure.

postscript: Click the edit widget below if it's not already open.
`
      }
      switch (intChoice) {
        case 1:
          return choices.minimal;
        case 2:
          return choices.full;
        case 3:
          return choices.cheatsheet
        default:
          return choices.minimal
      }
    }
    // makeNewScoreDivAndLink creates a new score div and a link to the div
    // and returns them as an array. The div contains a <details> element that
    // that contains the <pre> element that contains the source code. The link
    // points to the table of scores in the document.  The caller is responsible
    // for inserting the div and the link in the desired locations in the document.
    function makeNewScoreDivAndLink(content) {
      const div = document.createElement('div');
      div.setAttribute('class', 'score');
      const id = `score-${Math.random().toString(36).substring(2, 15)}`;
      div.setAttribute('id', id);

      const details = document.createElement('details');
      details.setAttribute('open', '');
      summary = document.createElement('summary');
      summary.textContent = 'Edit this score';
      details.appendChild(summary);

      const pre = document.createElement('pre');
      pre.setAttribute('class', 'source');
      pre.setAttribute('contenteditable', 'plaintext-only');
      pre.textContent = content;
      details.appendChild(pre);

      // Add a delete button to the new score that invokes deleteScore()
      // after asking for confirmation
      const deleteButton = document.createElement('button');
      deleteButton.setAttribute('class', 'delete-btn');
      deleteButton.textContent = 'Delete';
      deleteButton.addEventListener('click', () => {
        if (confirm(`Are you sure you want to delete this score?`)) {
          deleteScore(id);
        }
      });
      details.appendChild(deleteButton);

      div.appendChild(details);
      div.appendChild(document.createElement('hr'));

      pre.addEventListener('input', () => {
        renderEditedScoreSource(div);
      });

      const tocId = "score-toc";
      const link = document.createElement('a');
      link.setAttribute('href', `#${tocId}`);
      link.setAttribute('class', 'link-to-toc');
      link.textContent = 'Table of Scores';

      return [div, link];
    }

    function insertNewScore(button, intChoice) {
      const content = newScoreContent(parseInt(intChoice));
      const [div, link] = makeNewScoreDivAndLink(content);
      button.parentNode.insertBefore(div, button.nextSibling);

      const newScoreButton = document.createElement('button');
      newScoreButton.setAttribute('class', 'new-score-btn');
      newScoreButton.setAttribute('id', `insert-new-${div.id}`);
      newScoreButton.textContent = 'Insert New Score';
      newScoreButton.addEventListener('click', handleNewScoreButtonClick);
      div.parentNode.insertBefore(newScoreButton, div.nextSibling);

      div.appendChild(link);
      renderEditedScoreSource(div);
    }
    // handleNewScoreButtonClick inserts a new score into current page immediately before the
    // button that invoked it.  The new consists of a div with class'score' that contains
    // a <details> element that contains a <pre> element of class 'source' and a Save button that
    // invokes saveAsHtmlFile().
    function handleNewScoreButtonClick(event) {
      console.log('handleNewScoreButtonClick');
      const button = event.target;
      dialog = document.getElementById('new-score-dialog');
      // replace the dialog with a clone
      // to prevent accumulation of event listeners.
      dialog.replaceWith(dialog.cloneNode(true));
      dialog = document.getElementById('new-score-dialog');

      const cancelButton = dialog.querySelector('button[type="reset"]');
      const confirmButton = dialog.querySelector('button[type="submit"]');

      const cancelHandler = () => {
        dialog.returnValue = '';
        dialog.close();
        return false;
      };
      const confirmHandler = () => {
        dialog.returnValue = dialog.querySelector('input[name="choice"]:checked').value;
        console.log(`New score dialog submitted with ${dialog.returnValue}`);
        return false;
      };

      cancelButton.addEventListener('click', cancelHandler);
      confirmButton.addEventListener('click', confirmHandler);

      dialog.addEventListener('close', () => {
        if (dialog.returnValue !== '') {
          console.log(`New score dialog closed with ${dialog.returnValue}`);
          insertNewScore(button, dialog.returnValue);
        }
        return false;
      });

      dialog.showModal();
      return false;
    }

    // The export method creates a text file consisting of the source texts of each
    // score in the document, catenated and separated by a blank line between scores.
    // The source texts are located in the pre elements with class'source'.
    function exportScores() {
      // Get the source texts of each score
      const scoreDivs = document.querySelectorAll('div.score');
      const scoreTexts = [];
      scoreDivs.forEach(div => {
        scoreTexts.push(div.querySelector('pre.source').textContent);
      });
      // Create a text file
      const blob = new Blob([scoreTexts.join('\nEndOfScore\n')], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.setAttribute('href', url);
      // get this html document's name and append '-source.fqs' to it.
      const fqsName = window.location.pathname.split('/').pop().replace('.html', '-source.fqs');
      a.setAttribute('download', fqsName);
      a.click();
      URL.revokeObjectURL(url);
      return false;
    }
    // The importFromFile method loads new score from a text file selected by the user.
    // First it splits the text file on '\nEndOfScore\n' and then creates a new score for
    // each source text. Each new score is inserted immediately after the last new score button
    // in the document.
    /*
    function importFromFile() {
      const file = document.createElement('input');
      file.setAttribute('type', 'file');
      file.setAttribute('accept', '.fqs');
      file.addEventListener('change', event => {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.addEventListener('load', event => {
          const text = event.target.result;
          const scoreTexts = text.split('\nEndOfScore\n');
          scoreTexts.forEach(scoreText => {
            const [div, link] = makeNewScoreDivAndLink(scoreText);
            const newScoreButtons = document.querySelectorAll(`button.new-score-btn`);
            let newScoreButton = newScoreButtons[newScoreButtons.length - 1]; // get the last new score button
            newScoreButton.parentNode.insertBefore(div, newScoreButton.nextSibling);
            // Add a new score button after the div
            newScoreButton = document.createElement('button');
            newScoreButton.setAttribute('class', 'new-score-btn');
            newScoreButton.setAttribute('id', `insert-new-${div.id}`);
            newScoreButton.textContent = 'Insert New Score';
            newScoreButton.addEventListener('click', handleNewScoreButtonClick);
            div.parentNode.insertBefore(newScoreButton, div.nextSibling);
 
            div.appendChild(link);
            renderEditedScoreSource(div);
          });
        });
        reader.readAsText(file);
      });
      file.click();
      return false;
    }
    */

    function appendScores(text) {
      const scoreTexts = text.split('\nEndOfScore\n');
      scoreTexts.forEach(scoreText => {
        const [div, link] = makeNewScoreDivAndLink(scoreText);
        const newScoreButtons = document.querySelectorAll(`button.new-score-btn`);
        let newScoreButton = newScoreButtons[newScoreButtons.length - 1]; // get the last new score button
        newScoreButton.parentNode.insertBefore(div, newScoreButton.nextSibling);
        // Add a new score button after the div
        newScoreButton = document.createElement('button');
        newScoreButton.setAttribute('class', 'new-score-btn');
        newScoreButton.setAttribute('id', `insert-new-${div.id}`);
        newScoreButton.textContent = 'Insert New Score';
        newScoreButton.addEventListener('click', handleNewScoreButtonClick);
        div.parentNode.insertBefore(newScoreButton, div.nextSibling);

        div.appendChild(link);
        renderEditedScoreSource(div);
      });
    }

    function importFromFile() {
      const file = document.createElement('input');
      file.setAttribute('type', 'file');
      file.setAttribute('accept', '.fqs');
      file.addEventListener('change', event => {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.addEventListener('load', event => {
          const text = event.target.result;
          appendScores(text);
        });
        reader.readAsText(file);
      });
      file.click();
      return false;
    }

    function importFromURL() {
      const url = prompt('Enter the URL of the .fqs file:');
      if (url) {
        fetch(url)
          .then(response => response.text())
          .then(text => {
            try {
              appendScores(text);
            } catch {
              console.error('Error fetching .fqs file:', error);
              alert('Error(s) encountered. Scores may be incorrectly rendered or may not be rendered at all.');
            }
          })
          .catch(error => {
            console.error('Error fetching .fqs file:', error);
            alert('Failed to fetch the .fqs file. Please check the URL and try again.');
          });
      }
      return false;
    }

    // updateFontSizes() updates the font sizes of the various elements of
    // scores that will be rendered as SVG objects. The font default sizes are
    // specified in the style element with id 'fqs-style', but we support
    // overriding them via the bookParameters object. If the font sizes are not
    // specified in the bookParameters object, we use the default font sizes and
    // update corresponding vars in bookParameters.
    function updateFontSizes() {
      // Update the font sizes if user has specified them.
      // First, get a reference to the stylesheet,
      const stylesheet = document.getElementById('fqs-style').sheet;
      const rules = stylesheet.cssRules || stylesheet.rules;
      // then loop over the rules to update font sizes if specified
      // if not specified we need to assign a numeric value for use
      // in svg y coordinate calculations.
      for (let i = 0; i < rules.length; i++) {
        switch (rules[i].selectorText) {
          case '.title':
            if (bookParameters.titleFontHeight) {
              rules[i].style.fontSize = bookParameters.titleFontHeight + 'px';
            } else {
              bookParameters.titleFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
          case '.chord':
            if (bookParameters.chordFontHeight) {
              rules[i].style.fontSize = bookParameters.chordFontHeight + 'px';
            } else {
              bookParameters.chordFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
          case '.pernote':
            if (bookParameters.pernoteFontHeight) {
              rules[i].style.fontSize = bookParameters.pernoteFontHeight + 'px';
            } else {
              bookParameters.pernoteFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
          case '.lyric':
            if (bookParameters.lyricFontHeight) {
              rules[i].style.fontSize = bookParameters.lyricFontHeight + 'px';
            } else {
              bookParameters.lyricFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
          case '.pitch':
            if (bookParameters.pitchFontHeight) {
              rules[i].style.fontSize = bookParameters.pitchFontHeight + 'px';
            } else {
              bookParameters.pitchFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
          case '.cue':
            if (bookParameters.cueFontHeight) {
              rules[i].style.fontSize = bookParameters.cueFontHeight + 'px';
            } else {
              bookParameters.cueFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
          case '.perbar':
            if (bookParameters.perbarFontHeight) {
              rules[i].style.fontSize = bookParameters.perbarFontHeight + 'px';
            } else {
              bookParameters.perbarFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
          case '.perbeat':
            if (bookParameters.perbeatFontHeight) {
              rules[i].style.fontSize = bookParameters.perbeatFontHeight + 'px';
            } else {
              bookParameters.perbeatFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
          case '.lineproblem':
            if (bookParameters.lineproblemFontHeight) {
              rules[i].style.fontSize = bookParameters.lineproblemFontHeight + 'px';
            } else {
              bookParameters.lineproblemFontHeight = +rules[i].style.fontSize.slice(0, -2);
            }
            break;
        }
      }
    }


    // When the window load is complete, render the scores and add listeners to
    // the buttons that invoke the functions to insert, save and delete scores.
    window.onload = () => {
      // update the stylesheet with any font sizes specified in the bookParameters object
      // We need to make sure the font size vars in bookParameters and the style rules are in sync.
      updateFontSizes();
      // render the scores
      const scoreDivs = document.querySelectorAll('div.score');
      scoreDivs.forEach(div => {
        renderEditedScoreSource(div);
        // Add listeners for input events on the score source.
        const input = div.querySelector('pre.source');
        input.addEventListener('input', () => {
          renderEditedScoreSource(div);
        });
        // Add a listener for click events on the delete button.
        const deleteButton = div.querySelector('button.delete-btn');
        deleteButton.addEventListener('click', () => {
          if (confirm(`Are you sure you want to delete this score?`)) {
            deleteScore(div.id);
          }
        });
        // Add a listener for click events on the new score button associated with
        // this div.
        const newScoreButton = document.getElementById(`insert-new-${div.id}`);
        newScoreButton.addEventListener('click', insertNewScore);
      });
    }
  </script>
</body>

</html>